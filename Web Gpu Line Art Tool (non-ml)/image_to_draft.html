<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU çº¿ç¨¿æå–å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 210, 255, 0.3);
        }

        .controls {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.9em;
            color: #aaa;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d2ff, #3a7bd5);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 210, 255, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(245, 87, 108, 0.4);
        }

        select, input[type="range"] {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 1em;
            min-width: 150px;
        }

        select option {
            background: #1a1a2e;
            color: white;
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #00d2ff, #3a7bd5);
            border-radius: 50%;
            cursor: pointer;
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 25px;
        }

        @media (max-width: 900px) {
            .canvas-container {
                grid-template-columns: 1fr;
            }
        }

        .canvas-wrapper {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }

        .canvas-wrapper h3 {
            margin-bottom: 15px;
            color: #aaa;
        }

        canvas {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .info-panel h3 {
            margin-bottom: 15px;
            color: #00d2ff;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
        }

        .info-item .label {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 5px;
        }

        .info-item .value {
            font-size: 1.2em;
            font-weight: 600;
            color: #00d2ff;
        }

        .algorithm-desc {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            line-height: 1.6;
        }

        #status {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: 500;
        }

        .status-success {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }

        .status-error {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
        }

        .status-processing {
            background: rgba(0, 210, 255, 0.2);
            color: #00d2ff;
        }

        .threshold-value {
            display: inline-block;
            min-width: 40px;
            text-align: center;
            color: #00d2ff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¨ WebGPU çº¿ç¨¿æå–å·¥å…·</h1>

        <div class="controls">
            <div class="control-group">
                <label for="imageInput">é€‰æ‹©å›¾ç‰‡</label>
                <label class="btn btn-primary" for="imageInput">ğŸ“ ä¸Šä¼ å›¾ç‰‡</label>
                <input type="file" id="imageInput" accept="image/*">
            </div>

            <div class="control-group">
                <label for="algorithm">è¾¹ç¼˜æ£€æµ‹ç®—æ³•</label>
                <select id="algorithm">
                    <option value="sobel">Sobel ç®—å­</option>
                    <option value="prewitt">Prewitt ç®—å­</option>
                    <option value="laplacian">Laplacian ç®—å­</option>
                    <option value="roberts">Roberts äº¤å‰ç®—å­</option>
                    <option value="scharr">Scharr ç®—å­</option>
                    <option value="canny">Canny è¾¹ç¼˜æ£€æµ‹</option>
                    <option value="adaptive">è‡ªé€‚åº”åŒºåŸŸæ£€æµ‹</option>
                </select>
            </div>

            <div class="control-group">
                <label for="threshold">é˜ˆå€¼: <span id="thresholdValue" class="threshold-value">30</span></label>
                <input type="range" id="threshold" min="1" max="255" value="30">
            </div>

            <div class="control-group">
                <label for="lineStrength">çº¿æ¡å¼ºåº¦: <span id="lineStrengthValue" class="threshold-value">1.0</span></label>
                <input type="range" id="lineStrength" min="0.5" max="3.0" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label for="invert">åè½¬é¢œè‰²</label>
                <select id="invert">
                    <option value="1">ç™½åº•é»‘çº¿</option>
                    <option value="0">é»‘åº•ç™½çº¿</option>
                </select>
            </div>

            <button class="btn btn-secondary" id="downloadBtn">ğŸ’¾ ä¸‹è½½çº¿ç¨¿</button>
        </div>

        <div id="status"></div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h3>ğŸ“· åŸå§‹å›¾ç‰‡</h3>
                <canvas id="inputCanvas"></canvas>
            </div>
            <div class="canvas-wrapper">
                <h3>âœï¸ çº¿ç¨¿è¾“å‡º</h3>
                <canvas id="outputCanvas"></canvas>
            </div>
        </div>

        <div class="info-panel">
            <h3>ğŸ“Š å¤„ç†ä¿¡æ¯</h3>
            <div class="info-grid">
                <div class="info-item">
                    <div class="label">å›¾ç‰‡å°ºå¯¸</div>
                    <div class="value" id="imageSize">-</div>
                </div>
                <div class="info-item">
                    <div class="label">å¤„ç†æ—¶é—´</div>
                    <div class="value" id="processTime">-</div>
                </div>
                <div class="info-item">
                    <div class="label">åƒç´ æ€»æ•°</div>
                    <div class="value" id="pixelCount">-</div>
                </div>
                <div class="info-item">
                    <div class="label">å½“å‰ç®—æ³•</div>
                    <div class="value" id="currentAlgorithm">-</div>
                </div>
            </div>
            <div class="algorithm-desc" id="algorithmDesc">
                è¯·ä¸Šä¼ å›¾ç‰‡å¼€å§‹å¤„ç†...
            </div>
        </div>
    </div>

    <script>
        // WebGPU çº¿ç¨¿æå–å™¨ç±»
        class LineArtExtractor {
            constructor() {
                this.device = null;
                this.context = null;
                this.pipelines = {};
                this.initialized = false;
            }

            async init() {
                if (!navigator.gpu) {
                    throw new Error('WebGPU ä¸å—æ”¯æŒï¼Œè¯·ä½¿ç”¨æœ€æ–°ç‰ˆ Chrome/Edge æµè§ˆå™¨');
                }

                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    throw new Error('æ— æ³•è·å– WebGPU é€‚é…å™¨');
                }

                this.device = await adapter.requestDevice();
                this.initialized = true;

                // åˆ›å»ºæ‰€æœ‰ç®—æ³•çš„ç€è‰²å™¨
                await this.createPipelines();
            }

            // Sobel ç®—å­ç€è‰²å™¨
            getSobelShader() {
                return `
                    struct Params {
                        width: u32,
                        height: u32,
                        threshold: f32,
                        lineStrength: f32,
                        invert: u32,
                        padding1: u32,
                        padding2: u32,
                        padding3: u32,
                    }

                    @group(0) @binding(0) var<storage, read> input: array<u32>;
                    @group(0) @binding(1) var<storage, read_write> output: array<u32>;
                    @group(0) @binding(2) var<uniform> params: Params;

                    fn getGray(idx: u32) -> f32 {
                        let pixel = input[idx];
                        let r = f32((pixel >> 0u) & 0xFFu);
                        let g = f32((pixel >> 8u) & 0xFFu);
                        let b = f32((pixel >> 16u) & 0xFFu);
                        return 0.299 * r + 0.587 * g + 0.114 * b;
                    }

                    fn getPixelGray(x: i32, y: i32) -> f32 {
                        let cx = clamp(x, 0, i32(params.width) - 1);
                        let cy = clamp(y, 0, i32(params.height) - 1);
                        return getGray(u32(cy) * params.width + u32(cx));
                    }

                    @compute @workgroup_size(16, 16)
                    fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
                        let x = gid.x;
                        let y = gid.y;

                        if (x >= params.width || y >= params.height) {
                            return;
                        }

                        let ix = i32(x);
                        let iy = i32(y);

                        // Sobel kernels
                        let gx = -1.0 * getPixelGray(ix-1, iy-1) + 1.0 * getPixelGray(ix+1, iy-1)
                               + -2.0 * getPixelGray(ix-1, iy)   + 2.0 * getPixelGray(ix+1, iy)
                               + -1.0 * getPixelGray(ix-1, iy+1) + 1.0 * getPixelGray(ix+1, iy+1);

                        let gy = -1.0 * getPixelGray(ix-1, iy-1) + -2.0 * getPixelGray(ix, iy-1) + -1.0 * getPixelGray(ix+1, iy-1)
                               +  1.0 * getPixelGray(ix-1, iy+1) +  2.0 * getPixelGray(ix, iy+1) +  1.0 * getPixelGray(ix+1, iy+1);

                        var magnitude = sqrt(gx * gx + gy * gy) * params.lineStrength;

                        var edge: f32;
                        if (magnitude > params.threshold) {
                            edge = clamp(magnitude / 255.0, 0.0, 1.0);
                        } else {
                            edge = 0.0;
                        }

                        var finalColor: u32;
                        if (params.invert == 1u) {
                            let gray = u32((1.0 - edge) * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        } else {
                            let gray = u32(edge * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        }

                        output[y * params.width + x] = finalColor;
                    }
                `;
            }

            // Prewitt ç®—å­ç€è‰²å™¨
            getPrewittShader() {
                return `
                    struct Params {
                        width: u32,
                        height: u32,
                        threshold: f32,
                        lineStrength: f32,
                        invert: u32,
                        padding1: u32,
                        padding2: u32,
                        padding3: u32,
                    }

                    @group(0) @binding(0) var<storage, read> input: array<u32>;
                    @group(0) @binding(1) var<storage, read_write> output: array<u32>;
                    @group(0) @binding(2) var<uniform> params: Params;

                    fn getGray(idx: u32) -> f32 {
                        let pixel = input[idx];
                        let r = f32((pixel >> 0u) & 0xFFu);
                        let g = f32((pixel >> 8u) & 0xFFu);
                        let b = f32((pixel >> 16u) & 0xFFu);
                        return 0.299 * r + 0.587 * g + 0.114 * b;
                    }

                    fn getPixelGray(x: i32, y: i32) -> f32 {
                        let cx = clamp(x, 0, i32(params.width) - 1);
                        let cy = clamp(y, 0, i32(params.height) - 1);
                        return getGray(u32(cy) * params.width + u32(cx));
                    }

                    @compute @workgroup_size(16, 16)
                    fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
                        let x = gid.x;
                        let y = gid.y;

                        if (x >= params.width || y >= params.height) {
                            return;
                        }

                        let ix = i32(x);
                        let iy = i32(y);

                        // Prewitt kernels
                        let gx = -1.0 * getPixelGray(ix-1, iy-1) + 1.0 * getPixelGray(ix+1, iy-1)
                               + -1.0 * getPixelGray(ix-1, iy)   + 1.0 * getPixelGray(ix+1, iy)
                               + -1.0 * getPixelGray(ix-1, iy+1) + 1.0 * getPixelGray(ix+1, iy+1);

                        let gy = -1.0 * getPixelGray(ix-1, iy-1) + -1.0 * getPixelGray(ix, iy-1) + -1.0 * getPixelGray(ix+1, iy-1)
                               +  1.0 * getPixelGray(ix-1, iy+1) +  1.0 * getPixelGray(ix, iy+1) +  1.0 * getPixelGray(ix+1, iy+1);

                        var magnitude = sqrt(gx * gx + gy * gy) * params.lineStrength;

                        var edge: f32;
                        if (magnitude > params.threshold) {
                            edge = clamp(magnitude / 255.0, 0.0, 1.0);
                        } else {
                            edge = 0.0;
                        }

                        var finalColor: u32;
                        if (params.invert == 1u) {
                            let gray = u32((1.0 - edge) * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        } else {
                            let gray = u32(edge * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        }

                        output[y * params.width + x] = finalColor;
                    }
                `;
            }

            // Laplacian ç®—å­ç€è‰²å™¨
            getLaplacianShader() {
                return `
                    struct Params {
                        width: u32,
                        height: u32,
                        threshold: f32,
                        lineStrength: f32,
                        invert: u32,
                        padding1: u32,
                        padding2: u32,
                        padding3: u32,
                    }

                    @group(0) @binding(0) var<storage, read> input: array<u32>;
                    @group(0) @binding(1) var<storage, read_write> output: array<u32>;
                    @group(0) @binding(2) var<uniform> params: Params;

                    fn getGray(idx: u32) -> f32 {
                        let pixel = input[idx];
                        let r = f32((pixel >> 0u) & 0xFFu);
                        let g = f32((pixel >> 8u) & 0xFFu);
                        let b = f32((pixel >> 16u) & 0xFFu);
                        return 0.299 * r + 0.587 * g + 0.114 * b;
                    }

                    fn getPixelGray(x: i32, y: i32) -> f32 {
                        let cx = clamp(x, 0, i32(params.width) - 1);
                        let cy = clamp(y, 0, i32(params.height) - 1);
                        return getGray(u32(cy) * params.width + u32(cx));
                    }

                    @compute @workgroup_size(16, 16)
                    fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
                        let x = gid.x;
                        let y = gid.y;

                        if (x >= params.width || y >= params.height) {
                            return;
                        }

                        let ix = i32(x);
                        let iy = i32(y);

                        // Laplacian kernel (8-connected)
                        let laplacian = -1.0 * getPixelGray(ix-1, iy-1) + -1.0 * getPixelGray(ix, iy-1) + -1.0 * getPixelGray(ix+1, iy-1)
                                      + -1.0 * getPixelGray(ix-1, iy)   +  8.0 * getPixelGray(ix, iy)   + -1.0 * getPixelGray(ix+1, iy)
                                      + -1.0 * getPixelGray(ix-1, iy+1) + -1.0 * getPixelGray(ix, iy+1) + -1.0 * getPixelGray(ix+1, iy+1);

                        var magnitude = abs(laplacian) * params.lineStrength;

                        var edge: f32;
                        if (magnitude > params.threshold) {
                            edge = clamp(magnitude / 255.0, 0.0, 1.0);
                        } else {
                            edge = 0.0;
                        }

                        var finalColor: u32;
                        if (params.invert == 1u) {
                            let gray = u32((1.0 - edge) * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        } else {
                            let gray = u32(edge * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        }

                        output[y * params.width + x] = finalColor;
                    }
                `;
            }

            // Roberts äº¤å‰ç®—å­ç€è‰²å™¨
            getRobertsShader() {
                return `
                    struct Params {
                        width: u32,
                        height: u32,
                        threshold: f32,
                        lineStrength: f32,
                        invert: u32,
                        padding1: u32,
                        padding2: u32,
                        padding3: u32,
                    }

                    @group(0) @binding(0) var<storage, read> input: array<u32>;
                    @group(0) @binding(1) var<storage, read_write> output: array<u32>;
                    @group(0) @binding(2) var<uniform> params: Params;

                    fn getGray(idx: u32) -> f32 {
                        let pixel = input[idx];
                        let r = f32((pixel >> 0u) & 0xFFu);
                        let g = f32((pixel >> 8u) & 0xFFu);
                        let b = f32((pixel >> 16u) & 0xFFu);
                        return 0.299 * r + 0.587 * g + 0.114 * b;
                    }

                    fn getPixelGray(x: i32, y: i32) -> f32 {
                        let cx = clamp(x, 0, i32(params.width) - 1);
                        let cy = clamp(y, 0, i32(params.height) - 1);
                        return getGray(u32(cy) * params.width + u32(cx));
                    }

                    @compute @workgroup_size(16, 16)
                    fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
                        let x = gid.x;
                        let y = gid.y;

                        if (x >= params.width || y >= params.height) {
                            return;
                        }

                        let ix = i32(x);
                        let iy = i32(y);

                        // Roberts Cross kernels
                        let gx = getPixelGray(ix, iy) - getPixelGray(ix+1, iy+1);
                        let gy = getPixelGray(ix+1, iy) - getPixelGray(ix, iy+1);

                        var magnitude = sqrt(gx * gx + gy * gy) * params.lineStrength * 1.5;

                        var edge: f32;
                        if (magnitude > params.threshold) {
                            edge = clamp(magnitude / 255.0, 0.0, 1.0);
                        } else {
                            edge = 0.0;
                        }

                        var finalColor: u32;
                        if (params.invert == 1u) {
                            let gray = u32((1.0 - edge) * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        } else {
                            let gray = u32(edge * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        }

                        output[y * params.width + x] = finalColor;
                    }
                `;
            }

            // Scharr ç®—å­ç€è‰²å™¨ (æ¯”Sobelæ›´ç²¾ç¡®)
            getScharrShader() {
                return `
                    struct Params {
                        width: u32,
                        height: u32,
                        threshold: f32,
                        lineStrength: f32,
                        invert: u32,
                        padding1: u32,
                        padding2: u32,
                        padding3: u32,
                    }

                    @group(0) @binding(0) var<storage, read> input: array<u32>;
                    @group(0) @binding(1) var<storage, read_write> output: array<u32>;
                    @group(0) @binding(2) var<uniform> params: Params;

                    fn getGray(idx: u32) -> f32 {
                        let pixel = input[idx];
                        let r = f32((pixel >> 0u) & 0xFFu);
                        let g = f32((pixel >> 8u) & 0xFFu);
                        let b = f32((pixel >> 16u) & 0xFFu);
                        return 0.299 * r + 0.587 * g + 0.114 * b;
                    }

                    fn getPixelGray(x: i32, y: i32) -> f32 {
                        let cx = clamp(x, 0, i32(params.width) - 1);
                        let cy = clamp(y, 0, i32(params.height) - 1);
                        return getGray(u32(cy) * params.width + u32(cx));
                    }

                    @compute @workgroup_size(16, 16)
                    fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
                        let x = gid.x;
                        let y = gid.y;

                        if (x >= params.width || y >= params.height) {
                            return;
                        }

                        let ix = i32(x);
                        let iy = i32(y);

                        // Scharr kernels (more accurate than Sobel)
                        let gx = -3.0 * getPixelGray(ix-1, iy-1) + 3.0 * getPixelGray(ix+1, iy-1)
                               + -10.0 * getPixelGray(ix-1, iy)  + 10.0 * getPixelGray(ix+1, iy)
                               + -3.0 * getPixelGray(ix-1, iy+1) + 3.0 * getPixelGray(ix+1, iy+1);

                        let gy = -3.0 * getPixelGray(ix-1, iy-1) + -10.0 * getPixelGray(ix, iy-1) + -3.0 * getPixelGray(ix+1, iy-1)
                               +  3.0 * getPixelGray(ix-1, iy+1) +  10.0 * getPixelGray(ix, iy+1) +  3.0 * getPixelGray(ix+1, iy+1);

                        var magnitude = sqrt(gx * gx + gy * gy) * params.lineStrength / 16.0;

                        var edge: f32;
                        if (magnitude > params.threshold) {
                            edge = clamp(magnitude / 255.0, 0.0, 1.0);
                        } else {
                            edge = 0.0;
                        }

                        var finalColor: u32;
                        if (params.invert == 1u) {
                            let gray = u32((1.0 - edge) * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        } else {
                            let gray = u32(edge * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        }

                        output[y * params.width + x] = finalColor;
                    }
                `;
            }

            // Canny è¾¹ç¼˜æ£€æµ‹ç€è‰²å™¨ (ç®€åŒ–ç‰ˆ - åŒ…å«é«˜æ–¯æ¨¡ç³Šã€æ¢¯åº¦è®¡ç®—ã€éæå¤§å€¼æŠ‘åˆ¶)
            getCannyShader() {
                return `
                    struct Params {
                        width: u32,
                        height: u32,
                        threshold: f32,
                        lineStrength: f32,
                        invert: u32,
                        padding1: u32,
                        padding2: u32,
                        padding3: u32,
                    }

                    @group(0) @binding(0) var<storage, read> input: array<u32>;
                    @group(0) @binding(1) var<storage, read_write> output: array<u32>;
                    @group(0) @binding(2) var<uniform> params: Params;

                    fn getGray(idx: u32) -> f32 {
                        let pixel = input[idx];
                        let r = f32((pixel >> 0u) & 0xFFu);
                        let g = f32((pixel >> 8u) & 0xFFu);
                        let b = f32((pixel >> 16u) & 0xFFu);
                        return 0.299 * r + 0.587 * g + 0.114 * b;
                    }

                    fn getPixelGray(x: i32, y: i32) -> f32 {
                        let cx = clamp(x, 0, i32(params.width) - 1);
                        let cy = clamp(y, 0, i32(params.height) - 1);
                        return getGray(u32(cy) * params.width + u32(cx));
                    }

                    fn gaussianBlur(x: i32, y: i32) -> f32 {
                        // 5x5 Gaussian kernel
                        let kernel = array<f32, 25>(
                            1.0, 4.0, 7.0, 4.0, 1.0,
                            4.0, 16.0, 26.0, 16.0, 4.0,
                            7.0, 26.0, 41.0, 26.0, 7.0,
                            4.0, 16.0, 26.0, 16.0, 4.0,
                            1.0, 4.0, 7.0, 4.0, 1.0
                        );

                        var sum: f32 = 0.0;
                        for (var j: i32 = -2; j <= 2; j++) {
                            for (var i: i32 = -2; i <= 2; i++) {
                                let kidx = (j + 2) * 5 + (i + 2);
                                sum += getPixelGray(x + i, y + j) * kernel[kidx];
                            }
                        }
                        return sum / 273.0;
                    }

                    @compute @workgroup_size(16, 16)
                    fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
                        let x = gid.x;
                        let y = gid.y;

                        if (x >= params.width || y >= params.height) {
                            return;
                        }

                        let ix = i32(x);
                        let iy = i32(y);

                        // Apply Gaussian blur first
                        let blurred = gaussianBlur(ix, iy);

                        // Sobel gradients on blurred image
                        let gx = -1.0 * gaussianBlur(ix-1, iy-1) + 1.0 * gaussianBlur(ix+1, iy-1)
                               + -2.0 * gaussianBlur(ix-1, iy)   + 2.0 * gaussianBlur(ix+1, iy)
                               + -1.0 * gaussianBlur(ix-1, iy+1) + 1.0 * gaussianBlur(ix+1, iy+1);

                        let gy = -1.0 * gaussianBlur(ix-1, iy-1) + -2.0 * gaussianBlur(ix, iy-1) + -1.0 * gaussianBlur(ix+1, iy-1)
                               +  1.0 * gaussianBlur(ix-1, iy+1) +  2.0 * gaussianBlur(ix, iy+1) +  1.0 * gaussianBlur(ix+1, iy+1);

                        let magnitude = sqrt(gx * gx + gy * gy);
                        let angle = atan2(gy, gx);

                        // Non-maximum suppression
                        var neighbor1: f32 = 0.0;
                        var neighbor2: f32 = 0.0;

                        let absAngle = abs(angle);
                        if (absAngle < 0.3927 || absAngle > 2.7489) {
                            // Horizontal edge
                            neighbor1 = sqrt(pow(-1.0 * gaussianBlur(ix-1, iy-1) + 1.0 * gaussianBlur(ix+1, iy-1)
                                           + -2.0 * gaussianBlur(ix-1, iy)   + 2.0 * gaussianBlur(ix+1, iy)
                                           + -1.0 * gaussianBlur(ix-1, iy+1) + 1.0 * gaussianBlur(ix+1, iy+1), 2.0)
                                         + pow(-1.0 * gaussianBlur(ix-1, iy-1) + -2.0 * gaussianBlur(ix, iy-1) + -1.0 * gaussianBlur(ix+1, iy-1)
                                           +  1.0 * gaussianBlur(ix-1, iy+1) +  2.0 * gaussianBlur(ix, iy+1) +  1.0 * gaussianBlur(ix+1, iy+1), 2.0));
                        }

                        var edge = magnitude * params.lineStrength;

                        // Double threshold
                        let lowThresh = params.threshold * 0.5;
                        let highThresh = params.threshold;

                        var finalEdge: f32;
                        if (edge > highThresh) {
                            finalEdge = 1.0;
                        } else if (edge > lowThresh) {
                            finalEdge = 0.5;
                        } else {
                            finalEdge = 0.0;
                        }

                        var finalColor: u32;
                        if (params.invert == 1u) {
                            let gray = u32((1.0 - finalEdge) * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        } else {
                            let gray = u32(finalEdge * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        }

                        output[y * params.width + x] = finalColor;
                    }
                `;
            }

            // è‡ªé€‚åº”åŒºåŸŸæ£€æµ‹ç€è‰²å™¨ (ç”¨æˆ·æè¿°çš„æ–¹æ³•)
            getAdaptiveShader() {
                return `
                    struct Params {
                        width: u32,
                        height: u32,
                        threshold: f32,
                        lineStrength: f32,
                        invert: u32,
                        padding1: u32,
                        padding2: u32,
                        padding3: u32,
                    }

                    @group(0) @binding(0) var<storage, read> input: array<u32>;
                    @group(0) @binding(1) var<storage, read_write> output: array<u32>;
                    @group(0) @binding(2) var<uniform> params: Params;

                    fn getGray(idx: u32) -> f32 {
                        let pixel = input[idx];
                        let r = f32((pixel >> 0u) & 0xFFu);
                        let g = f32((pixel >> 8u) & 0xFFu);
                        let b = f32((pixel >> 16u) & 0xFFu);
                        return 0.299 * r + 0.587 * g + 0.114 * b;
                    }

                    fn getPixelGray(x: i32, y: i32) -> f32 {
                        let cx = clamp(x, 0, i32(params.width) - 1);
                        let cy = clamp(y, 0, i32(params.height) - 1);
                        return getGray(u32(cy) * params.width + u32(cx));
                    }

                    @compute @workgroup_size(16, 16)
                    fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
                        let x = gid.x;
                        let y = gid.y;

                        if (x >= params.width || y >= params.height) {
                            return;
                        }

                        let ix = i32(x);
                        let iy = i32(y);

                        // å½“å‰åƒç´ ä½œä¸ºåŸºå‡†
                        let centerGray = getPixelGray(ix, iy);

                        // æ£€æµ‹8ä¸ªæ–¹å‘çš„é‚»å±…
                        var maxDiff: f32 = 0.0;
                        var boundaryCount: u32 = 0u;

                        // 8ä¸ªæ–¹å‘çš„åç§»
                        let dx = array<i32, 8>(-1, 0, 1, -1, 1, -1, 0, 1);
                        let dy = array<i32, 8>(-1, -1, -1, 0, 0, 1, 1, 1);

                        for (var i: u32 = 0u; i < 8u; i++) {
                            let neighborGray = getPixelGray(ix + dx[i], iy + dy[i]);
                            let diff = abs(centerGray - neighborGray);

                            if (diff > maxDiff) {
                                maxDiff = diff;
                            }

                            // è¶…å‡ºé˜ˆå€¼åˆ™è®¤ä¸ºæ˜¯è¾¹ç•Œ
                            if (diff > params.threshold) {
                                boundaryCount++;
                            }
                        }

                        // æ‰©å±•æ£€æµ‹èŒƒå›´ (åŠå¾„2)
                        for (var dy2: i32 = -2; dy2 <= 2; dy2++) {
                            for (var dx2: i32 = -2; dx2 <= 2; dx2++) {
                                if (abs(dx2) == 2 || abs(dy2) == 2) {
                                    let neighborGray = getPixelGray(ix + dx2, iy + dy2);
                                    let diff = abs(centerGray - neighborGray);
                                    if (diff > maxDiff) {
                                        maxDiff = diff;
                                    }
                                }
                            }
                        }

                        // è®¡ç®—è¾¹ç¼˜å¼ºåº¦
                        var edgeStrength: f32 = 0.0;

                        // å¦‚æœå‘¨å›´æœ‰è¶³å¤Ÿå¤šçš„è¾¹ç•Œç‚¹ï¼Œæˆ–è€…æœ€å¤§å·®å¼‚è¶…è¿‡é˜ˆå€¼
                        if (boundaryCount >= 2u || maxDiff > params.threshold * 1.5) {
                            edgeStrength = maxDiff * params.lineStrength / 255.0;
                            edgeStrength = clamp(edgeStrength, 0.0, 1.0);
                        }

                        // å¢å¼ºè¾¹ç¼˜ï¼šä½¿ç”¨æ¢¯åº¦ä¿¡æ¯
                        let gradX = getPixelGray(ix + 1, iy) - getPixelGray(ix - 1, iy);
                        let gradY = getPixelGray(ix, iy + 1) - getPixelGray(ix, iy - 1);
                        let gradMag = sqrt(gradX * gradX + gradY * gradY);

                        if (gradMag > params.threshold) {
                            edgeStrength = max(edgeStrength, gradMag * params.lineStrength / 255.0);
                        }

                        edgeStrength = clamp(edgeStrength, 0.0, 1.0);

                        var finalColor: u32;
                        if (params.invert == 1u) {
                            let gray = u32((1.0 - edgeStrength) * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        } else {
                            let gray = u32(edgeStrength * 255.0);
                            finalColor = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);
                        }

                        output[y * params.width + x] = finalColor;
                    }
                `;
            }

            async createPipelines() {
                const algorithms = {
                    sobel: this.getSobelShader(),
                    prewitt: this.getPrewittShader(),
                    laplacian: this.getLaplacianShader(),
                    roberts: this.getRobertsShader(),
                    scharr: this.getScharrShader(),
                    canny: this.getCannyShader(),
                    adaptive: this.getAdaptiveShader()
                };

                for (const [name, shader] of Object.entries(algorithms)) {
                    const module = this.device.createShaderModule({ code: shader });

                    this.pipelines[name] = this.device.createComputePipeline({
                        layout: 'auto',
                        compute: {
                            module: module,
                            entryPoint: 'main'
                        }
                    });
                }
            }

            async process(imageData, algorithm, threshold, lineStrength, invert) {
                const { width, height, data } = imageData;

                // åˆ›å»ºè¾“å…¥ç¼“å†²åŒº
                const inputBuffer = this.device.createBuffer({
                    size: data.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                    mappedAtCreation: true
                });
                new Uint8Array(inputBuffer.getMappedRange()).set(data);
                inputBuffer.unmap();

                // åˆ›å»ºè¾“å‡ºç¼“å†²åŒº
                const outputBuffer = this.device.createBuffer({
                    size: data.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
                });

                // åˆ›å»ºå‚æ•°ç¼“å†²åŒº
                const paramsBuffer = this.device.createBuffer({
                    size: 32, // 8 x 4 bytes
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                });

                const paramsData = new ArrayBuffer(32);
                const paramsView = new DataView(paramsData);
                paramsView.setUint32(0, width, true);
                paramsView.setUint32(4, height, true);
                paramsView.setFloat32(8, threshold, true);
                paramsView.setFloat32(12, lineStrength, true);
                paramsView.setUint32(16, invert, true);
                paramsView.setUint32(20, 0, true); // padding
                paramsView.setUint32(24, 0, true); // padding
                paramsView.setUint32(28, 0, true); // padding

                this.device.queue.writeBuffer(paramsBuffer, 0, paramsData);

                // åˆ›å»ºç»‘å®šç»„
                const pipeline = this.pipelines[algorithm];
                const bindGroup = this.device.createBindGroup({
                    layout: pipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: inputBuffer } },
                        { binding: 1, resource: { buffer: outputBuffer } },
                        { binding: 2, resource: { buffer: paramsBuffer } }
                    ]
                });

                // æ‰§è¡Œè®¡ç®—
                const commandEncoder = this.device.createCommandEncoder();
                const computePass = commandEncoder.beginComputePass();
                computePass.setPipeline(pipeline);
                computePass.setBindGroup(0, bindGroup);
                computePass.dispatchWorkgroups(
                    Math.ceil(width / 16),
                    Math.ceil(height / 16)
                );
                computePass.end();

                // è¯»å–ç»“æœ
                const readBuffer = this.device.createBuffer({
                    size: data.byteLength,
                    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
                });

                commandEncoder.copyBufferToBuffer(outputBuffer, 0, readBuffer, 0, data.byteLength);
                this.device.queue.submit([commandEncoder.finish()]);

                await readBuffer.mapAsync(GPUMapMode.READ);
                const resultData = new Uint8ClampedArray(readBuffer.getMappedRange().slice(0));
                readBuffer.unmap();

                // æ¸…ç†ç¼“å†²åŒº
                inputBuffer.destroy();
                outputBuffer.destroy();
                paramsBuffer.destroy();
                readBuffer.destroy();

                return new ImageData(resultData, width, height);
            }
        }

        // ç®—æ³•æè¿°
        const algorithmDescriptions = {
            sobel: `<strong>Sobel ç®—å­</strong>ï¼šä½¿ç”¨ 3Ã—3 å·ç§¯æ ¸åˆ†åˆ«è®¡ç®—æ°´å¹³å’Œå‚ç›´æ–¹å‘çš„æ¢¯åº¦ï¼Œç„¶ååˆæˆè¾¹ç¼˜å¼ºåº¦ã€‚è¿™æ˜¯æœ€å¸¸ç”¨çš„è¾¹ç¼˜æ£€æµ‹æ–¹æ³•ä¹‹ä¸€ï¼Œå¯¹å™ªå£°æœ‰ä¸€å®šçš„æŠ—å¹²æ‰°èƒ½åŠ›ã€‚`,
            prewitt: `<strong>Prewitt ç®—å­</strong>ï¼šä¸ Sobel ç±»ä¼¼ï¼Œä½†å·ç§¯æ ¸æƒé‡å‡åŒ€åˆ†å¸ƒã€‚è®¡ç®—é€Ÿåº¦å¿«ï¼Œä½†å¯¹å™ªå£°æ›´æ•æ„Ÿã€‚é€‚åˆå¤„ç†å¯¹æ¯”åº¦è¾ƒé«˜çš„å›¾åƒã€‚`,
            laplacian: `<strong>Laplacian ç®—å­</strong>ï¼šäºŒé˜¶å¾®åˆ†ç®—å­ï¼Œå¯¹æ‰€æœ‰æ–¹å‘çš„è¾¹ç¼˜éƒ½æ•æ„Ÿã€‚ä½¿ç”¨ 8 è¿é€šæ ¸ï¼Œèƒ½å¤Ÿæ£€æµ‹æ›´ç»†å¾®çš„è¾¹ç¼˜å˜åŒ–ï¼Œä½†å¯¹å™ªå£°éå¸¸æ•æ„Ÿã€‚`,
            roberts: `<strong>Roberts äº¤å‰ç®—å­</strong>ï¼šæœ€ç®€å•çš„è¾¹ç¼˜æ£€æµ‹ç®—å­ï¼Œä½¿ç”¨ 2Ã—2 å¯¹è§’çº¿æ–¹å‘çš„å·®åˆ†ã€‚è®¡ç®—é€Ÿåº¦æœ€å¿«ï¼Œä½†è¾¹ç¼˜å®šä½ç²¾åº¦è¾ƒä½ã€‚`,
            scharr: `<strong>Scharr ç®—å­</strong>ï¼šSobel ç®—å­çš„ä¼˜åŒ–ç‰ˆæœ¬ï¼Œæä¾›æ›´ç²¾ç¡®çš„æ¢¯åº¦è¿‘ä¼¼ã€‚ç‰¹åˆ«é€‚åˆæ£€æµ‹ç»†å°è¾¹ç¼˜å’Œé«˜ç²¾åº¦è¦æ±‚çš„åœºæ™¯ã€‚`,
            canny: `<strong>Canny è¾¹ç¼˜æ£€æµ‹</strong>ï¼šåŒ…å«é«˜æ–¯æ¨¡ç³Šã€æ¢¯åº¦è®¡ç®—ã€éæå¤§å€¼æŠ‘åˆ¶å’ŒåŒé˜ˆå€¼å¤„ç†ã€‚è¢«è®¤ä¸ºæ˜¯æœ€ä¼˜ç§€çš„è¾¹ç¼˜æ£€æµ‹ç®—æ³•ä¹‹ä¸€ï¼Œäº§ç”Ÿçš„è¾¹ç¼˜ç»†è€Œè¿ç»­ã€‚`,
            adaptive: `<strong>è‡ªé€‚åº”åŒºåŸŸæ£€æµ‹</strong>ï¼šåŸºäºæ‚¨æè¿°çš„æ–¹æ³•å®ç°ã€‚ä»¥æ¯ä¸ªåƒç´ ä¸ºåŸºå‡†ï¼Œå‘å‘¨å›´æ£€æµ‹é¢œè‰²å˜åŒ–ï¼Œè¶…å‡ºè®¾å®šæ³¢åŠ¨èŒƒå›´çš„ç‚¹è¢«æ ‡è®°ä¸ºè¾¹ç•Œã€‚ç»“åˆæ¢¯åº¦ä¿¡æ¯å¢å¼ºè¾¹ç¼˜æ•ˆæœã€‚`
        };

        // ä¸»ç¨‹åº
        let extractor = null;
        let currentImage = null;

        const inputCanvas = document.getElementById('inputCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const inputCtx = inputCanvas.getContext('2d');
        const outputCtx = outputCanvas.getContext('2d');

        async function init() {
            try {
                updateStatus('æ­£åœ¨åˆå§‹åŒ– WebGPU...', 'processing');
                extractor = new LineArtExtractor();
                await extractor.init();
                updateStatus('WebGPU åˆå§‹åŒ–æˆåŠŸï¼è¯·ä¸Šä¼ å›¾ç‰‡å¼€å§‹å¤„ç†ã€‚', 'success');
            } catch (error) {
                updateStatus(`é”™è¯¯: ${error.message}`, 'error');
                console.error(error);
            }
        }

        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status-${type}`;
        }

        async function processImage() {
            if (!extractor || !currentImage) return;

            const algorithm = document.getElementById('algorithm').value;
            const threshold = parseFloat(document.getElementById('threshold').value);
            const lineStrength = parseFloat(document.getElementById('lineStrength').value);
            const invert = parseInt(document.getElementById('invert').value);

            updateStatus('æ­£åœ¨å¤„ç†å›¾ç‰‡...', 'processing');
            document.getElementById('currentAlgorithm').textContent = algorithm.toUpperCase();
            document.getElementById('algorithmDesc').innerHTML = algorithmDescriptions[algorithm];

            const startTime = performance.now();

            try {
                const imageData = inputCtx.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
                const result = await extractor.process(imageData, algorithm, threshold, lineStrength, invert);

                outputCanvas.width = inputCanvas.width;
                outputCanvas.height = inputCanvas.height;
                outputCtx.putImageData(result, 0, 0);

                const endTime = performance.now();
                document.getElementById('processTime').textContent = `${(endTime - startTime).toFixed(2)} ms`;

                updateStatus('å¤„ç†å®Œæˆï¼', 'success');
            } catch (error) {
                updateStatus(`å¤„ç†é”™è¯¯: ${error.message}`, 'error');
                console.error(error);
            }
        }

        // äº‹ä»¶ç›‘å¬
        document.getElementById('imageInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const img = new Image();
            img.onload = () => {
                // é™åˆ¶æœ€å¤§å°ºå¯¸
                let width = img.width;
                let height = img.height;
                const maxSize = 2048;

                if (width > maxSize || height > maxSize) {
                    if (width > height) {
                        height = (height / width) * maxSize;
                        width = maxSize;
                    } else {
                        width = (width / height) * maxSize;
                        height = maxSize;
                    }
                }

                inputCanvas.width = width;
                inputCanvas.height = height;
                inputCtx.drawImage(img, 0, 0, width, height);

                currentImage = img;

                document.getElementById('imageSize').textContent = `${Math.round(width)} Ã— ${Math.round(height)}`;
                document.getElementById('pixelCount').textContent = (width * height).toLocaleString();

                processImage();
            };
            img.src = URL.createObjectURL(file);
        });

        document.getElementById('algorithm').addEventListener('change', processImage);

        document.getElementById('threshold').addEventListener('input', (e) => {
            document.getElementById('thresholdValue').textContent = e.target.value;
        });

        document.getElementById('threshold').addEventListener('change', processImage);

        document.getElementById('lineStrength').addEventListener('input', (e) => {
            document.getElementById('lineStrengthValue').textContent = e.target.value;
        });

        document.getElementById('lineStrength').addEventListener('change', processImage);

        document.getElementById('invert').addEventListener('change', processImage);

        document.getElementById('downloadBtn').addEventListener('click', () => {
            if (outputCanvas.width === 0) {
                updateStatus('è¯·å…ˆå¤„ç†å›¾ç‰‡ï¼', 'error');
                return;
            }

            const link = document.createElement('a');
            link.download = 'line-art.png';
            link.href = outputCanvas.toDataURL('image/png');
            link.click();
        });

        // åˆå§‹åŒ–
        init();
    </script>
</body>
</html>